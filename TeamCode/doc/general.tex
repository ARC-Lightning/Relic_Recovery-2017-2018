\documentclass{article}
\usepackage{hyperref}
% \usepackage{algorithm}
% \usepackage{algpseudocode}

\begin{document}
\title{The Lightning Codebase}
\author{FTC Team 4410 (Lightning)}
\date{November 2017}
\maketitle

\begin{abstract}
This abstract is to be completed when this article is finished.
\end{abstract}
\section{Style and Language}

\subsection{Kotlin}

\subsubsection{Definition}
Kotlin is a programming language that runs on the Java Virtual Machine (JVM) platform. It has been supported by Google as an official language for Android since May 2017. It offers cleaner and more concise syntax, support for multiple programming paradigms \textit{(such as functional)}, and is fully interoperable with Java. It is open source under the Apache 2.0 license. \href{https://developer.android.com/kotlin/index.html}{Click here for Google's introduction to Kotlin.}

\subsubsection{Comparison with Java}
% Discuss: lambdas, null safety!, string templates, singletons, data classes, operator overloading, collection mutability (and mutability in general)
\begin{description}

\item[Lambdas]
Whereas Java offers Runnables as an equivalent to a lambda with no parameters or return values\footnote{We ignored Java 8+ because FTC's official Robot Controller repository, at the time of writing, still uses Java 7.}, Kotlin offers full lambda support with parameters and implicit return values. This allows us to implement callback mappings in a readable, writable, and understandable way. For example, the \texttt{GamepadListener} class contains a \texttt{Map} from the \texttt{typealias} \texttt{GamepadProperty} to the \texttt{typealias} \texttt{GamepadRule}, both of which represent lambdas with a given set of input types. Lambdas are also extensively used in functional iterator transformations such as \texttt{map}, \texttt{filter}, and \texttt{reduce}. Kotlin's support for Lambdas and these methods makes implementations of these functions possible without third-party libraries, as opposed using Java 7.

\item[Null Safety]
Types in Kotlin are non-nullable by default, whereas any non-primitive type in Java can be \texttt{null}. Although this does not bring exciting new features to our code, it encourages us to handle null cases when the type is declared to be nullable, preventing \texttt{NullPointerException}s.

\item[Data Classes]
Data classes in Kotlin were designed to address use cases where the only responsibility of a class is to hold data. It implicitly provides functions such as \texttt{equals()} and \texttt{toString()} that are specialized for data. It eliminates the getter/setter pattern in Java, which produces plenty of boilerplate code. Data classes are used for the \texttt{Position} data structure in ACS, which includes a two-dimensional coordinate and an orientation in radians. Before the conversion to Kotlin, getters and setters were implemented for each field, using up to 50 lines\footnote{Including documentation but without the header (JavaDoc before the class declaration)}. The converted code only needed 1 concise line.

\end{description}

There are many other delightful features in Kotlin that boost developer productivity and satisfaction compared to Java. \href{https://kotlinlang.org/docs/reference/idioms.html}{Click here for some common idioms in Kotlin.}

\subsubsection{Low Entry Point}

Kotlin is developed by JetBrains. The platform on which Android Studio is based on, IntelliJ, is also developed by JetBrains. JetBrains is known for superb language support in IDEs, and Kotlin is no exception. IntelliJ's Kotlin plugin is capable of converting any Java file directly to Kotlin just by copy-and-paste, so developers on the team may choose to write in either language. Although consistency in language is encouraged, Kotlin's seamless support for Java inter-op allows our developers to also keep their code in Java---no practical disadvantage results from the mixing of both languages.

\subsection{Style Guide}

To ensure consistency in readability and formatting, our codebase is fully compliant with \href{https://android.github.io/kotlin-guides/style.html}{Google's Android Kotlin Style Guide}. Strict adherence to a style guide provides us with consistent code style that does not obstruct productivity and improves readability.

\subsubsection{Interfaces}

The codebase is split into well-defined modules that correspond to the individual subsystems present in the robot. For example, The \texttt{IGlyphManipulator} interface allows other parts of the code to access the output devices that control the glyph mechanism; the \texttt{IDrivetrain} interface provides vector-based abstraction of movement and rotation using the drivetrain. For each module there is an interface file (prefixed with \texttt{I}) and an arbitrary amount of classes that implement that interface. This separation of protocol and implementation was intended for independency of specific implementations, enabling it to be swapped for another without much disturbance to the codebase as a whole. With this capability, seamless integration of code across authors can be achieved.

\subsubsection{Responsibilities}

Each module in the codebase has specific responsibilities, such as operating the jewel knocker or moving the robot. This form of organization facilitates the location of bugs in the code and aligns with our principles, which are discussed below.

\subsection{Principles}

It is our belief that compliance with a set of well-regarded programming principles can drastically improve code maintainability and quality in general. It is anticipated that this codebase might be inherited by our team in upcoming years, and consequently the intelligibility and reusability of the code is crucial to future success. Below is an enumeration of the principles with which this codebase attempts to comply.
\begin{description}

\item[Minimizing Coupling]
Coupling can be roughly defined as the amount of interconnection between a pair of modules. Minimizing coupling increases the level of independence of each module and limits the sharing of data between them, making data and logic more self-sufficient. By doing so, modules can be maintained individually; logic can be modified without disrupting other modules unless changes to the interface are being made. Furthermore, reducing coupling improves readability by

\item[D.R.Y.]
\textit{D.R.Y.} stands for "Don't Repeat Yourself." Its execution encourages
\item[Readability]

\end{description}

\section{Technical Description}

\subsection{GameMap}

\subsection{Drivetrain}

\subsection{Autonomous Decision Making}

\subsection{Custom Telemetry}

\subsection{I/O Devices}

\end{document}