\documentclass[letterpaper]{article}
\usepackage{hyperref}
% \usepackage{algorithm}
% \usepackage{algpseudocode}

\begin{document}
\title{The Lightning Codebase}
\author{FTC Team 4410 (Lightning)}
\date{November 2017}
\maketitle

\begin{abstract}
This abstract is to be completed when this article is finished.
\end{abstract}
\section{Style and Language}

\subsection{Kotlin}

\subsubsection{Definition}
Kotlin is a programming language that runs on the Java Virtual Machine (JVM) platform. It has been supported by Google as an official language for Android since May 2017. It offers cleaner and more concise syntax, support for multiple programming paradigms \textit{(such as functional)}, and is fully interoperable with Java. It is open source under the Apache 2.0 license. \href{https://developer.android.com/kotlin/index.html}{Click here for Google's introduction to Kotlin.}

\subsubsection{Comparison with Java}
% Discuss: lambdas, null safety!, string templates, singletons, data classes, operator overloading, collection mutability (and mutability in general)
\begin{description}

\item[Lambdas]
Whereas Java offers Runnables as an equivalent to a lambda with no parameters or return values\footnote{We ignored Java 8+ because FTC's official Robot Controller repository, at the time of writing, still uses Java 7.}, Kotlin offers full lambda support with parameters and implicit return values. This allows us to implement callback mappings in a readable, writable, and understandable way. For example, the \texttt{GamepadListener} class contains a \texttt{Map} from the \texttt{typealias} \texttt{GamepadProperty} to the \texttt{typealias} \texttt{GamepadRule}, both of which represent lambdas with a given set of input types. Lambdas are also extensively used in functional iterator transformations such as \texttt{map}, \texttt{filter}, and \texttt{reduce}. Kotlin's support for Lambdas and these methods makes implementations of these functions possible without third-party libraries, as opposed using Java 7.

\item[Null Safety]
Types in Kotlin are non-nullable by default, whereas any non-primitive type in Java can be \texttt{null}. Although this does not bring exciting new features to our code, it encourages us to handle null cases when the type is declared to be nullable, preventing \texttt{NullPointerException}s.

\item[Data Classes]
Data classes in Kotlin were designed to address use cases where the only responsibility of a class is to hold data. It implicitly provides functions such as \texttt{equals()} and \texttt{toString()} that are specialized for data. It eliminates the getter/setter pattern in Java, which produces plenty of boilerplate code. Data classes are used for the \texttt{Position} data structure in ACS, which includes a two-dimensional coordinate and an orientation in radians. Before the conversion to Kotlin, getters and setters were implemented for each field, using up to 50 lines\footnote{Including documentation but without the header (JavaDoc before the class declaration)}. The converted code only needed 1 concise line.

\end{description}

There are many other delightful features in Kotlin that boost developer productivity and satisfaction compared to Java. \href{https://kotlinlang.org/docs/reference/idioms.html}{Click here for some common idioms in Kotlin.}

\subsubsection{Low Entry Point}

Kotlin is developed by JetBrains. The platform on which Android Studio is based on, IntelliJ, is also developed by JetBrains. JetBrains is known for superb language support in IDEs, and Kotlin is no exception. IntelliJ's Kotlin plugin is capable of converting any Java file directly to Kotlin just by copy-and-paste, so developers on the team may choose to write in either language. Although consistency in language is encouraged, Kotlin's seamless support for Java inter-op allows our developers to also keep their code in Java---no practical disadvantage results from the mixing of both languages.

\subsection{Style Guide}

To ensure consistency in readability and formatting, our codebase is fully compliant with \href{https://android.github.io/kotlin-guides/style.html}{Google's Android Kotlin Style Guide}. Strict adherence to a style guide provides us with consistent code style that does not obstruct productivity and improves readability.

\subsubsection{Interfaces}

The codebase is split into well-defined modules that correspond to the individual subsystems present in the robot. For example, The \texttt{IGlyphManipulator} interface allows other parts of the code to access the output devices that control the glyph mechanism; the \texttt{IDrivetrain} interface provides vector-based abstraction of movement and rotation using the drivetrain. For each module there is an interface file (prefixed with \texttt{I}) and an arbitrary amount of classes that implement that interface. This separation of protocol and implementation was intended for independency of specific implementations, enabling it to be swapped for another without much disturbance to other parts of the codebase. With this capability, seamless integration of code across authors can be achieved.

\subsubsection{Responsibilities}

Each module in the codebase has specific responsibilities, such as operating the jewel knocker or moving the robot. This form of organization facilitates the location of bugs in the code and aligns with our principles, which are discussed below.

\subsection{Principles}

It is our belief that compliance with a set of well-regarded programming principles can drastically improve code maintainability and quality in general. It is anticipated that this codebase might be inherited by our team in upcoming years, and so the intelligibility and reusability of the code is crucial to future success. Below is an enumeration of the principles with which this codebase attempts to comply.
\begin{description}

\item[Minimizing Coupling]
Coupling can be roughly defined as the amount of interconnection between a pair of modules. Minimizing coupling increases the level of independence of each module and limits the sharing of data between them, making data and logic more self-sufficient. By doing so, modules can be maintained individually; logic can be modified without disrupting other modules unless changes to the interface are being made. Furthermore, reducing coupling improves readability by minimizing the amount of inter-modular references, thereby making code more focused and straightforward.

\item[D.R.Y.]
\textit{D.R.Y.} stands for "Don't Repeat Yourself." Its adherence encourages the developer to reduce redundancy throughout the system through techniques such as creating utility functions (and thereby reducing average complexity per function), creating universal parameters to store configurable data, and eliminating extraneous or redundant computations. This technique provides considerable benefits to the maintainer, the reader, and the writer. Parameters that require fine-tuning only need to be altered in one location in the code; readers and writers can better understand the purpose and the implementation of each function, increasing abstraction and expanding the capacity of logical complexity.

\item[Simplicity]
There is no practical reason to artificially complicate code. Not only is this act counterproductive, it impedes future understanding and expansion. The quality of this project should be inversely proportional to the total amount of lines, given that the desired behaviors are fulfilled. Functions with high levels of abstraction should be optimized to follow natural language patterns such as prepositional phrases and adverbs. Ideal examples of this rule are demonstrated below.
\begin{center}
	\texttt{ToggleInput.from(gamepad1.x).controls(glypher.flywheel)}
	\texttt{sage.nextDecision(prefer = customSequence).perform()}
	\texttt{mecanum.drive((3, 3), Options.QUICKLY).then \{\dots\}}
\end{center}

\end{description}

\section{Technical Description}

\subsection{GameMap}
% It is debatable whether we are keeping this part of the code, so I'm not writing it until it has been proven to be beneficial to autonomous operation.
\subsection{Drivetrain}
With Mecanum wheels, the robot is able to move in at least 8 directions from a given point without turning. With careful adjustments to individual motor powers, the robot can move in any possible direction expressible in a pair of two-dimensional Cartesian coordinates; however, the accuracy of this method is uncertain, and thus there is an option to disable this feature for autonomous navigation. The drivetrain subsystem should be optimized and designed for their operation. It should be designed to work with both TeleOp and Autonomous logic as effortlessly as possible; it should also provide plenty of flexibility for testing and experimentation.

\subsubsection{Use of Vectors}
This interface presents movements as vectors on a 2D plane, in which the positive $y$ direction represents forward and the positive $x$ direction represents right. Note that the plane is \textbf{not} projected relative to the playing field, but rather to the robot, i.e. the direction that the robot is facing is the positive $y$ direction. A collection of examples is presented below.
\begin{center}
	$(1, 1) \rightarrow$ forwards for 1 inch, right for 1 inch (diagonal)
	
	$(5, -2) \rightarrow$ forwards for 5 inches, left for 2 inches
	
	$(-5.5, 0) \rightarrow$ backwards for 5.5 inches
\end{center}

\subsubsection{Internal Logic}
Mecanum wheels are placed in four relative positions to form a rectangle. A rectangle has two diagonals. In Mecanum movements, motors at the end of each of the diagonals have the same power value. Following the D.R.Y. principle, only two scalar values are necessary as output, and therefore the function described here takes two inputs---the $x$ and $y$ components of the vector---and produces two outputs---the power value for each diagonal. The following enumeration describes the steps necessary to calculate the desired power value for each motor from any given vector:
\begin{description}
	\item[Rotation]
	We have observed a relationship between the components of vectors and their corresponding power values. After rotating the given vector $45^\circ$ clockwise, the two components correspond to the desired power of each diagonal pair of motors. Consider the following examples:
\begin{center}
	$(0, 1) \rightarrow (\frac{\sqrt{2}}{2}, \frac{\sqrt{2}}{2})$: To move in the direction $(0, 1)$ \textit{(i.e. forward)}, Both pairs of motors should have power values that are positive and equal.
	
	$(-1, -1) \rightarrow (-\sqrt{2},0)$: To move in the direction $(-1, -1)$ \textit{(i.e. left and backward)}, one pair should run in reverse and the other pair should be stationary.
\end{center}
	
\end{description}

\subsubsection{Autonomous Methods}
To support the 2D processing involved in ACS, the drivetrain interface accepts any arbitrary vector from the origin as a parameter. It then applies desired movements to drivetrain motors to accomplish this task without turning the robot. This feature works directly with multipoint paths that are generated by ACS for effortless navigation. An optional power multiplier parameter is provided for customization of speed. The methods designed for TeleOp are optimized for being controlled in a synchronous loop. They

\subsection{Autonomous Decision Making}

\subsection{Custom Telemetry}

\subsection{I/O Devices}

\end{document}