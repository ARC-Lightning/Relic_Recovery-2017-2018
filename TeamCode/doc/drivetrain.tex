\documentclass{article}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}
\title{The Drivetrain Interface}
\author{FTC Team 4410 (Lightning)}
\date{October 2017}
\maketitle

\section{Introduction}
With Mecanum wheels, the robot is able to move in 8 directions from a given point without turning. To fully take advantage of this feature, the drivetrain subsystem should be optimized and designed to work with them. The subsystem should be designed to work with both TeleOp and Autonomous logic as effortlessly as possible \emph{(See Autonomous Coordinate System for how autonomous code may interact with the drivetrain)}; It should also provide plenty of flexibility for testing and experimentation purposes.

\subsection{Use of Vectors}
This interface presents movements as vectors on a 2D plane, in which the positive $y$ direction represents forward and the positive $x$ direction represents right. Note that the plane \textbf{is not} projected relative to the playing field, but rather to the robot, i.e. the direction in which the robot is facing equals the positive $y$ direction, and the robot's location is $(0,0)$, or the starting point of any vector in this context.

\section{Description}

\subsection{Autonomous Methods}
To support the 2D processing involved in ACS, the drivetrain interface accepts any arbitrary vector from the origin as a parameter. It then applies desired movements to drivetrain motors to accomplish this task without turning the robot. This feature works directly with multipoint paths that are generated by ACS for effortless navigation. An optional power multiplier parameter is provided for customization of speed.

\subsection{TeleOp Methods}
The methods designed for TeleOp are optimized for being controlled in a synchronous loop. They
\section{Implementation}


\begin{algorithm}
    \caption{Find path from $a$ to $b$}
    \begin{algorithmic}[1]
        \Procedure{A*}{$a,b$}
            \State $f \gets \{[a, 0]\}$ \Comment{Priority queue: Frontier}
            \State $p \gets \{a: \mathrm{nil}\}$ \Comment{Key-value map: Path}
            \State $c \gets \{a: 0\}$ \Comment{Key-value map: Cost to node}
            \While{$\#f>0$}
                \State $s \gets $ pop item from $f$ \Comment{Coordinate: Current node}

                \If{$s=b$}
                    \State \Return \Call{Backtrack}{$s,a,p$} \Comment{From $s$ to $a$ in $p$}
                \EndIf

                \For{$n \gets$ \Call{Neighbors}{$s$}} \Comment{Coordinate: Next node}
                    \State $o \gets c[s]+\Call{Cost}{s,n}$ \Comment{Real: Cost to next node}
                    \If{$(n \notin c) \lor (o<c[n])$} \Comment{New cheapest cost to $n$}
                        \State $c[n] \gets o$
                        \State put $n$ into $f$ with priority $o+\Call{Heuristic}{b,n}$
                        \State $p[n] \gets s$
                    \EndIf
                \EndFor
            \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

If the algorithm above were to be used with the result directly fed to the drivetrain manager, the robot would stop itself everytime a new node is reached. To alleviate this ineffiency, the following algorithm converts the steps into a collection of points that describe when the driving direction changes.

\begin{algorithm}
	\caption{Convert nodes $P$ to points $p$}
	\begin{algorithmic}[1]
		\Require $P$ to be an array of coordinates
		\Procedure{ConvertPath}{$P$}
			\State $l \gets (0,0)$ \Comment{Last vector}
			\State $o \gets \emptyset$ \Comment{Output path (ORDERED)}
			\For{$i$ \textbf{in} $[1,\#P)$} \Comment{Index}
				\State $v \gets \overrightarrow{(P[i-1])(P[i])}$ \Comment{Current vector}
				\If{$v \ne l$}
					\State $o \gets o \cup \{P[i-1]\}$
					\State $l \gets v$
				\EndIf
			\EndFor
			\State \textbf{return} $o \cup \{P[\#P-1]\}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Consequently, the results from the above algorithm are converted to calls to the Drivetrain Manager in the following algorithm.

\begin{algorithm}
	\caption{Carry out navigation of points $p$}
	\begin{algorithmic}[1]
		\Require $p$ to be an array of coordinates
		\Procedure{Navigate}{$p$}
			\For{$i$ \textbf{in} $[1,\#p)$} \Comment{Index}
				\State Drivetrain.move(\overrightarrow{(p[i-1])(p[i])})
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
			
\end{document}